'use strict';

var core = require('@capacitor/core');

const SpeechSynthesis = core.registerPlugin('SpeechSynthesis', {
    web: () => Promise.resolve().then(function () { return web; }).then((m) => new m.SpeechSynthesisWeb()),
});

class SpeechSynthesisWeb extends core.WebPlugin {
    constructor() {
        super(...arguments);
        this.utteranceIdCounter = 0;
        this.currentUtterances = new Map();
    }
    async speak(options) {
        if (!('speechSynthesis' in window)) {
            throw new Error('Speech synthesis not supported in this browser');
        }
        const utteranceId = `web-utterance-${++this.utteranceIdCounter}`;
        const utterance = new SpeechSynthesisUtterance(options.text);
        // Set voice if specified
        if (options.voiceId) {
            const voices = window.speechSynthesis.getVoices();
            const voice = voices.find((v) => v.voiceURI === options.voiceId || v.name === options.voiceId);
            if (voice) {
                utterance.voice = voice;
            }
        }
        else if (options.language) {
            const voices = window.speechSynthesis.getVoices();
            const voice = voices.find((v) => v.lang === options.language);
            if (voice) {
                utterance.voice = voice;
            }
            utterance.lang = options.language;
        }
        // Set speech parameters
        if (options.pitch !== undefined) {
            utterance.pitch = Math.max(0, Math.min(2, options.pitch));
        }
        if (options.rate !== undefined) {
            utterance.rate = Math.max(0.1, Math.min(10, options.rate));
        }
        if (options.volume !== undefined) {
            utterance.volume = Math.max(0, Math.min(1, options.volume));
        }
        // Set up event listeners
        utterance.onstart = () => {
            this.notifyListeners('start', { utteranceId });
        };
        utterance.onend = () => {
            this.currentUtterances.delete(utteranceId);
            this.notifyListeners('end', { utteranceId });
        };
        utterance.onboundary = (event) => {
            this.notifyListeners('boundary', {
                utteranceId,
                charIndex: event.charIndex,
                charLength: event.charLength,
            });
        };
        utterance.onerror = (event) => {
            this.currentUtterances.delete(utteranceId);
            this.notifyListeners('error', {
                utteranceId,
                error: event.error || 'Unknown error',
            });
        };
        // Handle queue strategy
        if (options.queueStrategy === 'Flush') {
            window.speechSynthesis.cancel();
            this.currentUtterances.clear();
        }
        this.currentUtterances.set(utteranceId, utterance);
        window.speechSynthesis.speak(utterance);
        return { utteranceId };
    }
    async synthesizeToFile(_options) {
        throw new Error('synthesizeToFile is not supported on web platform');
    }
    async cancel() {
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel();
            this.currentUtterances.clear();
        }
    }
    async pause() {
        if ('speechSynthesis' in window) {
            window.speechSynthesis.pause();
        }
    }
    async resume() {
        if ('speechSynthesis' in window) {
            window.speechSynthesis.resume();
        }
    }
    async isSpeaking() {
        if ('speechSynthesis' in window) {
            return { isSpeaking: window.speechSynthesis.speaking };
        }
        return { isSpeaking: false };
    }
    async isAvailable() {
        return { isAvailable: 'speechSynthesis' in window };
    }
    async getVoices() {
        if (!('speechSynthesis' in window)) {
            return { voices: [] };
        }
        const webVoices = window.speechSynthesis.getVoices();
        const voices = webVoices.map((voice) => ({
            id: voice.voiceURI,
            name: voice.name,
            language: voice.lang,
            isNetworkConnectionRequired: !voice.localService,
            default: voice.default,
        }));
        return { voices };
    }
    async getLanguages() {
        if (!('speechSynthesis' in window)) {
            return { languages: [] };
        }
        const webVoices = window.speechSynthesis.getVoices();
        const languages = Array.from(new Set(webVoices.map((voice) => voice.lang)));
        return { languages };
    }
    async isLanguageAvailable(options) {
        if (!('speechSynthesis' in window)) {
            return { isAvailable: false };
        }
        const webVoices = window.speechSynthesis.getVoices();
        const isAvailable = webVoices.some((voice) => voice.lang === options.language);
        return { isAvailable };
    }
    async isVoiceAvailable(options) {
        if (!('speechSynthesis' in window)) {
            return { isAvailable: false };
        }
        const webVoices = window.speechSynthesis.getVoices();
        const isAvailable = webVoices.some((voice) => voice.voiceURI === options.voiceId || voice.name === options.voiceId);
        return { isAvailable };
    }
    async initialize() {
        // Pre-load voices on web
        if ('speechSynthesis' in window) {
            window.speechSynthesis.getVoices();
        }
    }
    async activateAudioSession(_options) {
        // Not applicable on web
    }
    async deactivateAudioSession() {
        // Not applicable on web
    }
    async getPluginVersion() {
        return { version: 'web' };
    }
}

var web = /*#__PURE__*/Object.freeze({
    __proto__: null,
    SpeechSynthesisWeb: SpeechSynthesisWeb
});

exports.SpeechSynthesis = SpeechSynthesis;
//# sourceMappingURL=plugin.cjs.js.map
